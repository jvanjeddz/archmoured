{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pre-Installation","text":""},{"location":"#the-very-first-thing","title":"The very first thing","text":"<p>This Arch Linux install guide illustrates the process on a virtual machine. Every command and code snippet will be presented  within code elements for easy identification and differentiation from regular text, such as this one: <pre><code>This is a code element\n</code></pre> This allows the reader to conveniently use the commands without ever reading all of these words (although  it is not recommended).</p>"},{"location":"#installation-image","title":"Installation image","text":"<p>To obtain an installation image, it is suggested to download an ISO file via HTTP  from one of the mirror sites listed in the Arch Linux HTTP Direct Downloads. It is recommended to verify the ISO signature to make sure it is safe to use.</p> <p>Once the site of choice has been selected, it greets with an index that contains the needed files. </p> <p></p> <p>Downloading the ISO file and one of the checksum txt files is necessary to see if the image matches the checksum.</p> <p></p> <p>It does! The SHA256 checksum can also be seen on the official website.</p> <p>If the reader is extra paranoid, the ISO PGP signature (the iso.sig file also found at the index) can be downloaded  in the same directory and verified (assuming that GnuPG, a libre encryption tool is already  installed) with:</p> <pre><code>gpg --keyserver-options auto-key-retrieve --verify archlinux-version-x86_64.iso.sig\n</code></pre> <p></p> <p>It is. It also matches the key fingerprint of the Arch Linux Developer who signed the ISO.</p> <p></p>"},{"location":"#installation-medium-preparation","title":"Installation medium preparation","text":"<p>Archmoured assumes that the reader already knows how to prepare an installation medium and boot from a live environment. It could be said that it is left as an exercise.</p> <p>Important: For this specific setup, it is necessary to be booting in UEFI mode. If not, both disk partitioning and bootloader used in this guide are going to be  incompatible with the reader's system.</p> <p>Protip: Ventoy gets the most out of an installation media (most likely an USB drive). </p>"},{"location":"#into-the-live-environment","title":"Into the live environment","text":"<p>Once booted, a shell prompt is presented.</p> <p></p>"},{"location":"#optional-set-console-font","title":"(Optional) Set console font","text":"<p>Those small characters may not be to everyone's liking. With the aim of making the shown screenshots readable, a larger font is selected. </p> <p></p> <p>Console fonts can be found in <code>usr/share/kbd/consolefonts/</code> and set with setfont.</p> <p></p>"},{"location":"#optional-set-console-keyboard-layout","title":"(Optional) Set console keyboard layout","text":"<p>The default console keymap is US. All available layouts can be found in <code>/usr/share/kbd/keymaps</code>. For example's sake, this guide will show how to set up the Latin American layout (la-latin1).  To list all the available keymaps, the command <code>locatectl list-keymaps</code> is used. Grep comes in handy when searching for a more specific result. Searching for this specific keymap can be done with:</p> <pre><code>localectl list-keymaps | grep -i la\n</code></pre> <p>Once located, it can be set up for the current session. This is done by using loadkeys. To set the already located layout, the loadkeys command followed by the chosen layout is used:</p> <pre><code>loadkeys la-latin1\n</code></pre> <p></p> <p>And there it is!</p>"},{"location":"#boot-mode-verification","title":"Boot mode verification","text":"<p>By running the following command, the boot mode is verified:</p> <pre><code>ls /sys/firmware/efi/efivars\n</code></pre> <p></p> <p>Since this virtual machine has EFI enabled, it shows the directory without error (and thus is booted in UEFI mode). If this directory does not exist on the system, the reader is strongly urged to check again and be sure that the system is booting neither from BIOS nor CSM. </p>"},{"location":"#internet-connection","title":"Internet connection","text":"<p>A network connection is required. An example won't be shown this time, although it is pretty straight-forward.</p> <p>Protip: When using Wi-Fi, the live environment offers iwctl.</p> <p>After setting it up, the connection can be verified by pinging  some host. It is traditional to test a connection by tickling Google's DNS (8.8.8.8):</p> <p></p> <p>It stops when interrupted with <code>Ctrl+c</code>.</p>"},{"location":"#system-clock-configuration","title":"System clock configuration","text":"<p>In the live environment, System-timesyncd is enabled  by default and time is synced automatically once the connection to the internet is established. By running  timedatectl, it can be ensured that the system clock is accurate:</p> <pre><code>timedatectl\n</code></pre> <p>It must show an accurate Universal Time Clock, that system clock is indeed synchronized, and that  NTP service is active. If for some reason NTP is inactive, it can be enabled again by using the <code>set-ntp</code> command.  It takes a boolean argument (true or false) and controls whether network time synchronization is active and enabled. If it's true, this enables and starts the first existing network synchronization service. It is then enabled by running  the following command: </p> <pre><code>timedatectl set-ntp true\n</code></pre>"},{"location":"#disk-partitioning","title":"Disk partitioning","text":"<p>Disks are assigned to a block device, a special file that provides buffered access to a hardware device. Using  fdisk allows to identify such devices:</p> <p></p> <p>This example shows that the storage device is handled by the kernel's  SCSI driver subsystem, thus it starts with <code>sd</code>. It sorts the devices from first to last discovered alphabetically. The device used on this guide is the <code>`sda</code> device shown  in the image, although it might not be the same for the reader. Results ending in rom, loop or airoot may be ignored. </p> <p>Guidance through the size of every block device is highly encouraged (as in not partitioning that 8G device the live environment booted from when the target  device has a 1TB HDD).</p> <p>To modify partition tables, fdisk may be used.</p> <pre><code>fdisk /dev/sda\n</code></pre> <p></p> <p>This setup uses an encrypted root partition and an EFI mode partition only. Usage of swap is left to the reader's discretion. </p> <p>Note: From the author's perspective, it is not necessary since his machine has enough RAM for what he has ever done and hibernation does not match  his usercase.</p> <p></p> <p>A new empty GPT partition label (by typing <code>g</code>)  is created, for these partitions are expected to boot in UEFI mode. </p> <p>Adding a new partition is done by typing <code>n</code>. To make of it the EFI system partition, the defaults for partition number and first sector are selected. </p> <p>In the last sector, the partition's size must be specified. This one must be at least 300 MiB and no more than 1 GiB  if multiple kernels are going to be installed (most of this later on). The author chooses to install 512 MiB, for he  likes powers of two.</p> <p>To give an example, the partition type is changed to EFI System by typing <code>t</code> and stating the partition type  (<code>1</code> for this one).</p> <p></p> <p>By typing <code>n</code> again and selecting the default option for everything, the partition table has a second partition with the default partition type: Linux filesystem.</p> <p>Even though it is not necessary, the image shows the verified partition table through <code>v</code> and the table itself  with <code>p</code>. Now it must be written to the disk and exit by typing <code>w</code>.</p> <p>In order to use luks for the created linux filesystem, an encrypted logical container must be initialized by using  cryptsetup:</p> <pre><code>cryptsetup luksFormat /dev/sda2\n</code></pre> <p>This prompts the user to create a passphrase.</p> <p>Via cryptsetup, the container must be opened followed by a placeholder. Any name suffices, but \"crypt\" is chosen  by sheer exemplification:</p> <pre><code>cryptsetup open /dev/sda2 crypt\n</code></pre> <p>The user must enter the created passphrase.</p> <p></p>"},{"location":"#partition-formatting","title":"Partition formatting","text":"<p>Once the partitions have been created, both must be formatted with their  appropriate file system.</p> <p>Formatting the EFI partition with FAT32 is done through:</p> <pre><code>mkfs.fat -F32 /dev/sda1\n</code></pre> <p>On the other hand, the root partition is formatted to btrfs. This filesystem has been chosen for its properties, such as compression and snapshot handling:</p> <pre><code>mkfs.btrfs /dev/mapper/crypt\n</code></pre> <p></p>"},{"location":"#partition-mounting","title":"Partition mounting","text":"<p>Root and home subvolumes are created within the btrfs partition. This eases the use of snapshots since this guide uses timeshift for its convenience out of the box. To manually mount a  file system located on a partition to a directory, mount is used: </p> <pre><code>mount /dev/mapper/crypt /mnt\n\nbtrfs sub create /mnt/@\n\nbtrfs sub create /mnt/@home\n</code></pre> <p>The /mnt directory must be unmounted so that it can be used when mounting the partitions:</p> <pre><code>umount /mnt\n</code></pre> <p></p> <p>The recently created subvolumes must be mounted.</p> <p>There are several options specified:</p> <ul> <li> <p><code>noatime</code>: fully disables writing file access times to the drive every time you read a file.</p> </li> <li> <p><code>nodiratime</code>: disables the writing of file access times only for directories while other files  still get access times written.</p> </li> <li> <p><code>compress=zstd</code> makes use of zstd. </p> </li> <li> <p><code>space_cache</code> gives control the free space cache. The free space cache greatly improves performance when  reading block group free space into memory. Version 2 adds a new B-tree called the free space tree, addressing  the issue that version 1 may have on large filesystems. </p> </li> <li> <p><code>ssd</code>optimizes the process on Solid State Drives.</p> </li> </ul> <pre><code>mount -o noatime,nodiratime,compress=zstd:1,space_cache=v2,ssd,subvol=@ /dev/mapper/crypt /mnt\n</code></pre> <p>Using the <code>--parents</code> option to make parents directories as needed. It is needed for the home subvolume and also the EFI partition.</p> <pre><code>mkdir -p /mnt/{boot,home}\n</code></pre> <p>Mounting home subvolume with the options that were given before:</p> <pre><code>mount -o noatime,nodiratime,compress=zstd:1,space_cache=v2,ssd,subvol=@home /dev/mapper/crypt /mnt/home\n</code></pre> <p>Mounting EFI partition on boot. No option is needed:</p> <pre><code>mount /dev/sda1 /mnt/boot\n</code></pre> <p></p>"},{"location":"about/","title":"About this site","text":"<p>Archmoured arises from the idea of documenting the installation of my current Arch install  with the purpose of deeply understanding everything I did (plagiarized) in order to obtain such  a solid system. As there are almost no up-to-date instructions for this specific setup, I decided  to share it on the internet in extreme detail so that anyone can replicate it and understand it as well.</p> <p>By using btrfs in order to make use of snapshots, luks for encryption and systemd-boot as bootloader,  this installation is truly unbreakable and easily recoverable. User-made mistakes are still a thing,  but any miscalculation is just a <code>timeshift --restore</code> away from going back to a functional, comfy setup.</p> <p>Archmoured does not intend to market itself as some kind of product/distro of its own. This is merely  a guide that intends to take you through a descriptive process that shows what to do, how  to do it and why is it important for the installation.</p> <p>This site wouldn't be possible without the help of these guides:</p> <ul> <li> <p>Arch Linux Installation guide</p> </li> <li> <p>Setting up Arch + LUKS + BTRFS + systemd-boot + apparmor + Secure Boot + TPM 2.0 - A long, nightmarish journey, now simplified</p> </li> <li> <p>Installing Arch Linux with Btrfs, systemd-boot and LUKS</p> </li> </ul>"},{"location":"barebones/","title":"Barebones","text":""},{"location":"barebones/#installation","title":"Installation","text":""},{"location":"barebones/#mirrors-selection","title":"Mirrors selection","text":"<p>Packages are downloaded from mirror servers. Reflector updates the mirror list by 20 most  recently synchronized HTTPS mirrors and sorting them by download rate after connecting to the internet on the live system.</p> <p>The higher a mirror is placed on the list, the more priority it is given when downloading a package. Usually, the one generated on the live system is fine. If not, it may be  edited.</p>"},{"location":"barebones/#essential-packages-installation","title":"Essential packages installation","text":"<p>Pacstrap is designed to create a new system installation from scratch. It is used to install specified packages into a given directory after setting up the mountpoints defined before (specifically into the root partition):</p> <pre><code>pacstrap /mnt base base-devel linux linux-firmware btrfs-progs vim intel-ucode\n</code></pre> <ul> <li> <p><code>base</code>: Minimal package set to define a basic Arch Linux installation</p> </li> <li> <p><code>base-devel</code>: Basic tools to build Arch Linux packages. It is useful to compile packages from source. More of this after getting a solid system.</p> </li> <li> <p><code>linux</code>: The Linux kernel and modules. There are various alternative  Linux kernels available for Arch Linux in addition  to the latest stable kernel. It is still suggested to use the vanilla one.</p> </li> <li> <p><code>linux-firmware</code>: Firmware files for Linux.</p> </li> <li> <p><code>btrfs-progs</code>: Btrfs filesystem utilities.</p> </li> <li> <p><code>intel-ucode</code>: Microcode update files for Intel  CPUs. These provide bug fixes that can be critical to the stability of your system. All users with  an AMD or Intel CPU should install the microcode updates to ensure system stability.</p> </li> <li> <p><code>vim</code>: Vi Improved, a highly configurable, improved version of the vi text editor. More of this  program later on.</p> </li> </ul>"},{"location":"barebones/#system-configuration","title":"System configuration","text":""},{"location":"barebones/#fstab","title":"Fstab","text":"<p>The fstab file can be used to define how disk partitions, various other block  devices, or remote file systems should be mounted into the file system. A fstab file is generated with:</p> <pre><code>genfstab -U /mnt &gt;&gt; /mnt/etc/fstab\n</code></pre> <p></p>"},{"location":"barebones/#chroot","title":"Chroot","text":"<p>A chroot is an operation that changes the parent root directory  for the current running process and their children. The following command changes root into the new system:</p> <pre><code>arch-chroot /mnt/\n</code></pre>"},{"location":"barebones/#time-zone","title":"TIme-zone","text":"<p>By running the following command, an <code>/etc/localtime</code> symlink that points to a zoneinfo is created. If the user's time zone name is unknown, it is recommended to play around by looking at the zoneinfo directory content (e.g.  <code>ls /usr/share/zoneinfo/</code>) to see which option is best suited. Replacing Region and City is necessary:</p> <pre><code>ln -sf /usr/share/zoneinfo/Region/City /etc/localtime\n</code></pre> <p>Hwclock is an administration tool for the time clocks. The following command sets the Hardware Clock from the System Clock and updates the timestamps found in /etc/adjtime:</p> <pre><code>hwclock --systohc\n</code></pre>"},{"location":"barebones/#localization","title":"Localization","text":"<p>To make use of the English language in the system, <code>en_US.UTF-8 UTF-8</code> found in <code>/etc/locale.gen</code> must be uncommented:</p> <pre><code>vim /etc/locale.gen\n</code></pre> <p>By using echo, it is possible to edit/create a file without having to use a text editor.  This command creates a locale.conf file and sets the LANG variable to the same uncommented above:</p> <pre><code>echo LANG=en_US.UTF-8 &gt; /etc/locale.conf\n</code></pre> <p>The locales are generated by running:</p> <pre><code>locale-gen\n</code></pre> <p></p>"},{"location":"barebones/#optional-persistent-keyboard-layout","title":"(Optional) Persistent keyboard layout","text":"<p>A persistent console keyboard layout can be specified by writing it on <code>/etc/vconsole.conf</code>. On the next example, the Latin American layout is chosen:</p> <pre><code>echo KEYMAP=la-latin1 &gt; /etc/vconsole.conf\n</code></pre>"},{"location":"barebones/#network-configuration","title":"Network configuration","text":"<p>The following command creates the hostname file an adds the system's hostname.  In this example, <code>myhost</code> is the hostname:</p> <pre><code>echo myhost &gt; /etc/hostname\n</code></pre> <p>Nss-myhostname provides localhost and the local hostname resolution to an  IP address. Still, some software may instead read <code>/etc/hosts</code> directly. To prevent such software from unsafely resolving  localhost over the network, entries for localhost are added. Resolving the local hostname is allowed by adding it too:</p> <pre><code>vim /etc/hosts\n</code></pre> <p>The following text must be added to the file:</p> <pre><code>127.0.0.1 localhost\n::1 localhost\n127.0.1.1 myhost.localdomain myhost\n</code></pre> <p></p> <p>A configuration for a system with a permanent IP address or a domain name can be done too, but this won't be covered in this guide.</p>"},{"location":"barebones/#initramfs","title":"Initramfs","text":"<p>The <code>mkinitcpio.conf</code> file must be edited, adding <code>btrfs</code> for it must be loaded before any boot hook. Inside <code>HOOKS</code>, <code>base udev systemd autodetect keyboard modconf block sd-encrypt filesystems</code> is added.</p> <ul> <li> <p><code>base</code>: provides crucial runtime necessities for booting.</p> </li> <li> <p><code>udev</code>: adds the udev daemon to the initramfs, allowing for dynamic loading of modules and reliable detection of  the root device via tags (UUID).</p> </li> <li> <p><code>systemd</code>: installs a basic systemd setup in the initramfs, and is meant to replace the <code>base</code>, <code>usr</code>,  <code>udev</code> and <code>resume</code> hooks. Other hooks with runtime components will need to be ported, and will not work  as intended. Including <code>base</code> hook before this one to ensure that a rescue shell exists on the initramfs is a good idea.</p> </li> <li> <p><code>autodetect</code>: shrinks the initramfs to a smaller size by autodetecting the needed modules.</p> </li> <li> <p><code>keyboard</code>: loads the necessary modules for keyboard devices.</p> </li> <li> <p><code>modconf</code>: installs modprobe configuration files from /etc/modprobe.d and /usr/lib/modprobe.d.</p> </li> <li> <p><code>block</code>: loads the necessary modules for most block devices using pata, sata, scsi, firewire, usb, or mmc.</p> </li> <li> <p><code>sd-encrypt</code>: allows for an encrypted root device with systemd initramfs.</p> </li> <li> <p><code>filesystems</code>: adds filesystems modules to the image.</p> </li> </ul> <pre><code>vim /etc/mkinitcpio.conf\n</code></pre> <p></p> <p>The initramfs image is recreated:</p> <pre><code>mkinitcpio -P\n</code></pre> <p></p>"},{"location":"barebones/#password-creation","title":"Password creation","text":"<p>A root password is set:</p> <pre><code>passwd\n</code></pre>"},{"location":"barebones/#user-creation","title":"User creation","text":"<p>With the following command, an user and the respective home directory is created. This user is wheel member. Wheel is the administration group, commonly used to give privileges to perform administrative actions. Even though it isn't the default, it can also be used to give access to the sudo  and su utilities. In the following example, <code>username</code> is the user's name:</p> <pre><code>useradd -m -G wheel username\n</code></pre> <p>The configuration for sudo is found in <code>/etc/sudoers</code>. It must be edited by using visudo. Visudo locks the sudoers file against multiple simultaneous edits, performs basic validity checks, and checks for syntax errors before installing the edited file. This prevents any error that could make of sudo inoperable.</p> <p>The default editor for visudo is vi. To establish vim as the visudo editor for the duration of the current shell session, <code>EDITOR=vim</code> is written before visudo:</p> <pre><code> EDITOR=vim visudo\n</code></pre> <p><code>%wheel ALL=(ALL) ALL</code> is uncommented to allow members of group wheel to execute any command:</p> <pre><code>%wheel ALL=(ALL) ALL\n</code></pre> <p>It is highly advised to set a password for the created user:</p> <pre><code>passwd username\n</code></pre> <p></p> <p>Using pacman, the following packages are installed:</p> <ul> <li> <p><code>linux-headers</code>: Headers and scripts for building modules for the Linux kernel.</p> </li> <li> <p><code>networkmanager</code>: Network connection manager and user applications.</p> </li> <li> <p><code>dialog</code>: A tool to display dialog boxes from shell scripts.</p> </li> <li> <p><code>wpa_supplicant</code>: A utility providing key negotiation for WPA wireless networks.</p> </li> <li> <p><code>mtools</code>: A collection of utilities to access MS-DOS disks</p> </li> <li> <p><code>dosfstools</code>: DOS filesystem utilities.</p> </li> <li> <p><code>git</code>: The fast distributed version control system.</p> </li> <li> <p><code>xdg-utils</code>: Command line tools that assist applications with a variety of desktop integration tasks.</p> </li> <li> <p><code>xdg-user-dirs</code>: Manages user directories like <code>~/Desktop</code> and <code>~/Music</code>.</p> </li> </ul> <pre><code>pacman -S linux-headers networkmanager dialog wpa_supplicant mtools dosfstools git xdg-utils xdg-user-dirs\n</code></pre> <p>The main command used to introspect and control systemd is systemctl.  Some of its uses are examining the system state and managing the system and services. The following command enables NetworkManager to start automatically at boot:</p> <pre><code>systemctl enable NetworkManager\n</code></pre> <p></p>"},{"location":"barebones/#bootloader","title":"Bootloader","text":""},{"location":"barebones/#systemd-boot-as-bootloader","title":"Systemd-boot as bootloader","text":"<p>A bootloader is a piece of software  started by the firmware. It is responsible for loading the kernel with the wanted kernel parameters  and any external initramfs images.</p> <p>This guide uses Systemd-boot. It is a pretty straight-forward boot manager. It is already included with Arch's init system,  Systemd. </p> <p>Bootctl is used to install systemd-boot to the EFI  System Partition's (ESP) mountpoint. In this case, it is mounted to <code>/boot</code>, for separation of concerns between OS and EFI related files is not wanted:</p> <pre><code> bootctl --path=/boot install\n</code></pre> <p></p> <p>Systemd-boot searches for boot menu items. In this specific configuration, in <code>/boot/loader/entries/arch.conf</code>. In order to use encryption, the root's UUID (Universally unique identifier) is used to identify such partition. It is added to the file, so it is not necessary to manually copy all of those characters:</p> <pre><code> echo $(blkid -s UUID -o value /dev/sda2) &gt;&gt; /boot/loader/entries/arch.conf\n</code></pre> <p></p> <p>The file is then edited:</p> <pre><code>vim boot/loader/entries/arch.conf \n</code></pre> <pre><code>title Arch Linux\nlinux /vmlinuz-linux\ninitrd /intel-ucode.img\ninitrd /initramfs-linux.img\noptions rd.luks.name=&lt;UUID&gt;=crypt root=/dev/mapper/crypt rootflags=subvol=@ rd.luks.options=&lt;UUID&gt;=discard rw quiet\n</code></pre> <p></p> <ul> <li><code>title</code>: The Operating System name.</li> <li><code>linux</code>: EFI program to start. Relative to the EFI System Partition.</li> <li><code>initrd</code>: It is used to state kernel parameters. </li> <li><code>options</code>: Options to pass to the EFI program or kernel parameters.</li> </ul> <p>Since this is a linux only boot, <code>linux</code> can be used instead of <code>efi</code>. The syntax differs in both cases.</p> <p>The loader configurations is found in <code>/boot/loader/loader.conf</code>:</p> <pre><code>vim /boot/loader/loader.conf\n</code></pre> <p>The following configuration is added:</p> <p></p>"},{"location":"barebones/#reboot","title":"Reboot","text":"<p>It is required to type <code>exit</code> or press <code>Ctrl+d</code> to exit the chroot environment:</p> <pre><code>exit\n</code></pre> <p>Even though it is not a must, the used partitions may be manually unmounted.</p> <pre><code>umount -R /mnt\n</code></pre> <p>The following command restarts the machine:</p> <pre><code>reboot\n</code></pre> <p></p>"},{"location":"post-install/","title":"Post-Installation","text":"<p>Once booted, the bootloader is displayed (if everything was done correctly).</p> <p></p> <p>The password created before is requested before getting into the system.</p> <p></p> <p>A larger font is selected.</p> <p></p>"},{"location":"post-install/#aur","title":"AUR","text":"<p>The Arch User Repository (AUR) is a community-driven  repository for Arch users. It contains package descriptions (PKGBUILDs) that allows users to compile a package  from source with makepkg and then install it via pacman. Every AUR package can be found here This is why installing <code>base-devel</code> is important if using the AUR is planned.</p> <p>Pacman is a package manager that is considered a huge advantage of Arch Linux and one of its major distinguishing features. It combines a simple binary package format with  an easy-to-use build system. All packages offered by pacman are found in the package search section.</p> <p>With the purpose of having an up-to-date system, the repository databases are synchronized, and the packages are updated with:</p> <pre><code>sudo pacman -Syu\n</code></pre> <p></p> <p>For convenience, an Arch User Repository helper is installed. These automate the usage of the AUR. Tasks such as package search,  resolving of dependencies, retrieving and building, and others are automated. This guide uses yay, although virtually any other helper can be used. </p> <p>Even though it is not necessary, a specific directory is selected to install this package's directory, so everything  is neat and tidy. The following example uses the <code>~/Downloads</code> directory created when installing <code>xdg-user-dirs</code>:</p> <pre><code>cd Downloads/\n</code></pre> <p>Since yay is written in Go, it is installed beforehand:</p> <pre><code>sudo pacman -S go\n</code></pre> <p>The package's git repository is cloned:</p> <pre><code>git clone https://aur.archlinux.org/yay.git\n</code></pre> <p>The directory is changed to the one containing the package's PKGBUILD:</p> <pre><code>cd yay/\n</code></pre> <p>The package is made by running <code>makepkg</code>. The <code>-i</code> flag installs the package if built successfully, so it is not necessary to do it manually:</p> <pre><code>makepkg -i\n</code></pre> <p></p>"},{"location":"post-install/#snapshots","title":"Snapshots","text":"<p>Now that yay is installed, it is used to install timeshift:</p> <pre><code>yay -S timeshift\n</code></pre> <p>Timeshift is a system restore tool. It creates filesystem  snapshots using BTRFS snapshots. </p> <p>A snapshot is created to test its functionality:</p> <pre><code>sudo timeshift --create --comments \"Testing...\"\n</code></pre> <p>Its creation is confirmed by listing the system's snapshots:</p> <pre><code>sudo timeshift --list\n</code></pre> <p></p> <p>It is. Any package is installed to test that restoration works. This example makes use of  cowsay:</p> <pre><code>sudo pacman -S cowsay\n</code></pre> <p></p> <p>Now that the package is installed, the created snapshot is restored.</p> <pre><code>sudo timeshift --restore\n</code></pre> <p></p> <p>The system is rebooted so that the snapshot becomes active. If this recently installed package is not there anymore, it means it worked:</p> <pre><code>reboot\n</code></pre> <p>It did. Cowsay is not installed anymore. Thus, the system is finally ready.</p> <p></p>"},{"location":"post-install/#graphical-user-interface","title":"Graphical User Interface","text":"<p>There it is. A minimal installation. For desktop use, it is highly recommended using a graphical environment. Choosing one can be a true hassle. For this, virtually any other guide suffices  since this distro is well-known for its ricing community. For now, Archmoured encourages the  use of Xfce, for it brings a truly stable  experience.</p>"}]}